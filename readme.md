<a id="readme-top"></a>

[![LinkedIn][linkedin-shield]][linkedin-url] [![Gmail Badge][gmail-shield]][gmail-url]


<!-- PROJECT LOGO -->
<br />
<div align="center">
    <img src="https://f.hubspotusercontent20.net/hubfs/8381278/Logo-Full%20(1).png" alt="Logo"  height="80">

  <h3 align="center">Musiversal Booking Platform App</h3>

  <p align="center">
    My Application for the Musiversal Full Stack Developer Challenge.
    <br />
    <br />
    <a href="">View Demo</a>
    ·
    <a href="https://bernardodmelo.portal.swaggerhub.com/musiversal/default/booking-platform-musiversal-api-v-1-0-0">Swagger API</a>
    
  </p>
</div>


<!-- ABOUT THE PROJECT -->
## About The Project
<div align="center">

![Product Name Screen Shot][product-screenshot]

</div>

Following the guidelines of this Tech Challenge, I created a **Musician Booking Platform**.

By accessing the application, users can choose from musicians who have enabled their presence on the app.

Once selected, users can provide their name, choose from available schedules (future ones or schedules where the musician doesn't have a booking yet), and select one of the services provided by the respective musician.

After submitting the form, a new session will appear at the bottom of the app, along with a close layout for the form. Users can decide whether they want to book more sessions or... practice their guitar riffs before the booked session 🎸

This project was a great experience for me, not only because it involves a context that I love, as a former musician, but also because I learned so many technologies during the process!


<p align="right">(<a href="#readme-top">back to top</a>)</p>



## Tech Stack Selection Explanation
*I aimed to choose the best combination of minimalism and software quality assurance.*

### Frontend

For the **Frontend**, I relied on technologies that could provide the best UI experience and ensure software quality.

In addition to the pre-chosen React, I decided to develop the entire code in **TypeScript**. I wanted to ensure that this project doesn't have any flaws or blind spots that could lead to unexpected bugs or errors. So, I believe Typescript' static typing approach benefits the maintainability and scalability of this project.

For fetching API data, I chose **Axios** due to its widespread adoption in the development world and, basically, its suits for this project's requirements. Additionally, I utilized **SWR** to combine React Hooks with Axios responses. This simplifies data fetching with React, removing useEffect and useState multiple calls.

To style the UI, I opted for **Tailwind CSS** for its balance between fast CSS development and customization flexibility —instead of just importing pre-styled ones, as is the case with UI libraries. If you check my `tailwind.config.json`, you can see that I collected all the colors from the shared Figma Design and created my custom color theme.

This project was generated by **Vite**. By its minimalist approach, the Evan You generator is way faster than the outdated Create React App. You can see [here](https://cdn.hashnode.com/res/hashnode/image/upload/v1644689198260/h6GIqKt5v.png?auto=compress,format&format=webp) a demonstration chart of this.

Unit testing is crucial for ensuring software quality. With a Vite project, I decided to experiment with **Vitest + React Testing Library**. Vitest runs faster than other testing libraries and is straightforward to use.


#### Generated by
![Vite](https://img.shields.io/badge/vite-%23646CFF.svg?style=for-the-badge&logo=vite&logoColor=white)

#### Developed with
![React Badge](https://img.shields.io/badge/React-61DAFB?logo=react&logoColor=000&style=for-the-badge) ![Typescript][Typescript]

#### Fetch REST API Data
![Axios][Axios] ![SWR][SWR]

#### Styling
![Tailwind CSS Badge](https://img.shields.io/badge/Tailwind%20CSS-06B6D4?logo=tailwindcss&logoColor=fff&style=for-the-badge)

#### Testing
![Vitest][Vitest] ![Testing Library Badge](https://img.shields.io/badge/Testing%20Library-E33332?logo=testinglibrary&logoColor=fff&style=for-the-badge)

<br>

### Backend (API) 
For the construction of the API, I chose TypeScript with the Node.js framework: **Express.js**. Express provides a minimalist approach that allowed me to create a REST API quickly.

Following the demanded requisites, to work with a Sqlite Database, the connector here was **Prisma**. I have known Prisma for long and decided to create my first API with this ORM, since it provides [so many features](https://www.prisma.io/typescript), regarding TypeScript development with this tool. However, it has flaws that made me slow my development, like this [one](https://github.com/prisma/prisma/issues/3084). *Maybe next time I use Sequelize?* 😂

For testing the REST API actions, I used **Jest** and **Supertest**. Jest offers a minimal setup with many actions to choose from, while Supertest allows for easy and safe testing of HTTP routes.


#### Developed with
![Express Badge](https://img.shields.io/badge/Express-000?logo=express&logoColor=fff&style=for-the-badge) ![Typescript][Typescript]

#### ORM
![Prisma Badge](https://img.shields.io/badge/Prisma-2D3748?logo=prisma&logoColor=fff&style=for-the-badge)

#### Database
![SQLite Badge](https://img.shields.io/badge/SQLite-003B57?logo=sqlite&logoColor=fff&style=for-the-badge) 

#### Testing
![Jest Badge](https://img.shields.io/badge/Jest-C21325?logo=jest&logoColor=fff&style=for-the-badge) ![Supertest](https://img.shields.io/badge/Supertest-black?style=for-the-badge)

<p align="right">(<a href="#readme-top">back to top</a>)</p>

<!-- GETTING STARTED -->
## Getting Started

### Prerequisites

To run the application on your computer, you must have [**SQLite**](https://www.sqlite.org/download.html), [**NodeJS**](https://nodejs.org/en/download) installed globally on your computer. 
<br>

### Installation

After this confirmation, you can git clone the project, by running the following command in your terminal: 

```sh
git clone https://github.com/bernardodemelo/musiversal-booking-platform.git
```

You'll get two directories inside this repo: one with the Frontend (**musiversal-app**) and another for the Backend(**musiversal-api**). Follow these steps:

1. Inside **musiversal-app**, you should create a .env file, write the following code and save it:
   ```sh
   VITE_SERVER_URL = "http://localhost:3000"
   ```

2. Then, still inside the directory, you should run the following installation command:
   ```sh
   npm install
   ```

3. Thereafter, inside **musiversal-api**, you should create another .env, write this code and save it: 
   ```sh
   DATABASE_URL="file:./dev.db"
   APP_URL = "http://localhost:5173"
   PORT = 3000"
   ```

4. Then, still inside the directory, you should run the following installation command:
   ```sh
   npm install
   ```

<br>

### Run the Project

Inside **musiversal-app**, to run the frontend, execute the following command: 
 ```sh
   npm run dev
   ```

And run the exact same command, in a separate terminal window, inside the **musiversal-app** directory, in order to run the Backend. 
<br>

### Test the Project

Inside **musiversal-app**, to test the Frotend, execute the following command: 
 ```sh
   npm run test
   ```

And run the exact command inside the **musiversal-app** directory, to test the Backend. 

<p align="right">(<a href="#readme-top">back to top</a>)</p>

<br>

<!-- Tech Choices -->
## Technical Choices

### Musicians Generator
After running the project, you'll see a message like this:
![terminal-log](https://i.ibb.co/NyxPmQZ/Screenshot-2024-02-19-at-00-27-35.png)

This basically indicates that your SQLite database has been seeded with a list of five musicians. The responsible function for this action is located in `/utils/actions/musiciansGenerator.ts`. You can check the seed data in `/utils/data/data.ts`.

I implemented this function because the application currently lacks an *Add Musician* feature (though it may be added in the future!). By seeding the database, users can experience the application without manually creating entries in their local sqlite database, allowing for a smoother experience. 🌱


<br>

### Four Models to Rule Them All 
If you check `/prisma/schema.prisma`, you're going to check that there are four data models to run this application. Why? First I wanted to respect the separation of concerns principle - dedicating one model to each element of data. Additionally, with this setup and relations, it offers better scalability for the current project when developing new features. For example, creating a new page only for available services (which may have many musicians offering them) becomes more straightforward.


<br>

### Filter in the API / Show in the UI
My approach to these two elements was to use the full power of the SQL Query Language and TypeScript's static typing and flexibility in terms of the actions it can provide, as a superset of JavaScript.

With that in mind, when running the `GET /api/musicians` endpoint to fetch musicians, the API's response does not include all musicians. Instead, it counts on backend filtering actions to only return musician objects that have the property **enabled** set to **true**.

In the same way, I applied the same approach when retrieving sessions using the `GET /api/sessions` endpoint. On the Database, sessions are saved with the date and time they were booked in a single string. Before sending the response, the backend filters the sessions and returns only those with a date that matches today's date. After this, it deconstructs the dates of the filtered sessions, returning only the hours to show them on the UI.


<br>

### Frontend's Folder Organization
```bash
├── __tests__
├── components
│   ├── blocks
│   │   └── cards
│   └── elements
│       ├── buttons
│       ├── dropdowns
│       ├── headings
│       └── inputs
├── containers
│   ├── forms
│   └── lists
├── layouts
├── pages
├── services
└── utils
    ├── data
    └── types
└── App.tsx
└── main.tsx
└── index.css
└── vite-env.d.ts
```

<br>

Being an application that I had to create from scratch, I had the freedom to decide on the folder organization in the frontend. For many months, I have been reading about [Atomic Design](https://bradfrost.com/blog/post/atomic-web-design/) and the way this pattern could be applied in [React's Folder Organization](https://medium.com/@janelle.wg/atomic-design-pattern-how-to-structure-your-react-application-2bb4d9ca5f97).

So, I decided that I would take into account that this project could be used for future development — so it needed to scale — and applied this pattern by categorizing components into smaller to bigger elements. From smaller to bigger elements, the folders that hold these components are:

elements ➡️ blocks ➡️ containers ➡️ pages ➡️ layout


<br>

<!-- Added Features -->
## Added Features
### Availability
What would it be to have musicians' availability stored in the app's database? That's what I thought when developing this Tech Challenge.

You're going to check out that a musician can have available time slots for each day of the week. The backend will check today's day of the week and return the time slots for the respective day.

SQLite doesn't work with arrays like other SQL databases such as PostgreSQL. As a workaround for this problem, I stringified the array of time slots when seeding musicians. To return them in a proper JS format, I parsed them.


<br>

### Sessions Data Persistence 
The initial solution for managing sessions in my app was simply updating my state. However, that didn't seem like a proper approach. So, I decided to create two routes: `GET /api/sessions` and `POST /api/session` that retrieve and create sessions in the API and persist the data.


<br>

<!-- ROADMAP -->
## Next Steps

- [ ] Develop Responsiveness for this Project;
- [ ] Dockerize and Deploy;
- [ ] Provide Authentication for the user, as so the musician;
- [ ] Integrate Google Calendar, so the Musician's availability could be related to his calendar availability.


<!-- CONTACT -->
## Contact Me!

**Thank you so much for reading this. I enjoyed every second!**

Bernardo de Melo - bernardodmelo@gmail.com

<p align="right">(<a href="#readme-top">back to top</a>)</p>





[linkedin-shield]: https://img.shields.io/badge/-LinkedIn-black.svg?style=for-the-badge&logo=linkedin&colorB=555
[linkedin-url]: https://www.linkedin.com/in/bernardo-de-melo/
[gmail-shield]:https://img.shields.io/badge/Gmail-EA4335?logo=gmail&logoColor=fff&style=for-the-badge
[gmail-url]:mailto:bernardodmelo@gmail.com
[product-screenshot]: https://i.ibb.co/WFqmJtg/Musiversal-Booking-Platform-ezgif-com-video-to-gif-converter.gif
[Typescript]:https://img.shields.io/badge/TypeScript-007ACC?style=for-the-badge&logo=typescript&logoColor=white
[Axios]: https://img.shields.io/badge/axios-671ddf?&style=for-the-badge&logo=axios&logoColor=white
[SWR]:https://img.shields.io/badge/SWR-000?logo=swr&logoColor=fff&style=for-the-badge
[Vitest]: https://img.shields.io/badge/Vitest-6E9F18?logo=vitest&logoColor=fff&style=for-the-badge
